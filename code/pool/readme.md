# 线程池 & 数据库连接池
## 线程池
使用线程池可以减少线程的销毁，而且如果不使用线程池的话，来一个客户端就创建一个线程。比如有1000，这样线程的创建、线程之间的调度也会耗费很多的系统资源，所以采用线程池使程序的效率更高。 线程池就是项目启动的时候，就先把线程池准备好。

一般线程池的实现是通过生产者消费者模型来的：
![](https://img-blog.csdnimg.cn/77a4124181da4fd69d200c1b532e57aa.png)

+ **线程同步问题**

线程同步问题涉及到了互斥量、条件变量。
在代码中，将互斥锁、条件变量、关闭状态、工作队列封装到了一起，通过一个共享智能指针来管理这些条件。

> 其实我不是很理解为啥要把他们封装到一个结构体中，可能是为了在构造函数中，创建线程时的匿名函数中捕获列表传值更方便吧。在捕获列表中，采用了this:函数体内可以使用Lambda所在类中的成员变量

鉴于本人对匿名函数不是很熟悉，所以在写的时候又去学习了一遍匿名函数。关于匿名函数的使用，参考这篇博客：https://blog.csdn.net/huangshanchun/article/details/47155859

在匿名函数中还用到了move，也是C++11的一个新特性，该函数的作用是将左值转换为右值，资产转移，该函数是为性能而生的。

## 数据库连接池
我见过的连接池有用std::list写的，也有用std::queue写的，我个人还是比较倾向于用queue写。 
+ 为什么要使用连接池？
    - 由于服务器需要频繁地访问数据库，即需要频繁创建和断开数据库连接，该过程是一个很耗时的操作，也会对数据库造成安全隐患。
    - 在程序初始化的时候，集中创建并管理多个数据库连接，可以保证较快的数据库读写速度，更加安全可靠。
+ RAII机制
    - C++的语言机制保证，当一个对象创建时会自动调用构造函数，当对象超出作用域时会自动调用析构函数。
    - 所以，我们可以使用类来管理资源，在构造函数中申请分配资源，在析构函数中释放资源。
    - RAII的核心思想是将资源与对象的生命周期绑定。

在连接池的实现中，使用到了信号量来管理资源的数量；而锁的使用则是为了在访问公共资源的时候使用。所以说，无论是条件变量还是信号量，都需要锁。

不同的是，信号量的使用要先使用信号量sem_wait再上锁，而条件变量的使用要先上锁再使用条件变量wait。